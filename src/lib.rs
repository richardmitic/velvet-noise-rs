extern crate rand;

use rand::distributions::{Bernoulli, Distribution};
use rand::rngs::{SmallRng, ThreadRng};
use rand::{Rng, SeedableRng};

/// Original Velvet Noise impulse location iterator
pub struct OVNImpulseLocations {
    m: std::ops::RangeFrom<usize>,
    td: usize,
    r1m: SmallRng,
}

impl OVNImpulseLocations {
    /// density is non-zero pulses per second
    /// sample_rate is total samples per second
    pub fn new(density: usize, sample_rate: usize) -> OVNImpulseLocations {
        OVNImpulseLocations {
            m: (0..),
            td: sample_rate / density,
            r1m: SmallRng::from_entropy(),
        }
    }
}

impl Iterator for OVNImpulseLocations {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        let val = (self.m.next().unwrap() * self.td) + self.r1m.gen_range(0, self.td);
        Some(val)
    }
}

/// Additive Random Noise impulse location iterator
pub struct ARNImpulseLocations {
    m_prev: f32,
    td_minus_1: f32,
    delta: f32,
    r1m: ThreadRng,
}

impl ARNImpulseLocations {
    /// density is non-zero pulses per second
    /// sample_rate is total samples per second
    pub fn new(density: f32, sample_rate: f32, delta: f32) -> ARNImpulseLocations {
        ARNImpulseLocations {
            m_prev: 0.,
            td_minus_1: (sample_rate / density) - 1.,
            delta: delta,
            r1m: rand::thread_rng(),
        }
    }
}

impl Iterator for ARNImpulseLocations {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        let val = self.m_prev
            + 1.
            + (self.td_minus_1 * (1. - self.delta))
            + (2. * self.delta * self.td_minus_1 * self.r1m.gen::<f32>());
        self.m_prev = val;
        Some(val as usize)
    }
}

/// Random sequence of negative/positive samples
pub struct Choice(Bernoulli, SmallRng);

impl Choice {
    /// Crushed (skewed) sample choice
    pub fn crushed(skew: f64) -> Choice {
        Choice(Bernoulli::new(skew).unwrap(), SmallRng::from_entropy())
    }

    /// Classic sample choice
    pub fn classic() -> Choice {
        Choice::crushed(0.5)
    }
}

impl Iterator for Choice {
    type Item = f32;

    fn next(&mut self) -> Option<Self::Item> {
        match self.0.sample(&mut self.1) {
            true => Some(1.),
            false => Some(-1.),
        }
    }
}

/// Velvet Noise Kernal
/// Iterator that will generate (index, coefficient) pairs.
/// All indices not given in a pair are assumed to contain a 0 coefficient
pub struct VelvetNoiseKernel<T: Iterator<Item = usize>, U: Iterator<Item = f32>>(pub T, pub U);

impl<T, U> Iterator for VelvetNoiseKernel<T, U>
where
    T: Iterator<Item = usize>,
    U: Iterator<Item = f32>,
{
    type Item = (usize, f32);

    fn next(&mut self) -> Option<Self::Item> {
        match (self.0.next(), self.1.next()) {
            (Some(i), Some(x)) => Some((i, x)),
            _ => None,
        }
    }
}

/// Audio signal generated by the given kernel
pub struct VelvetNoise<VelvetNoiseKernel> {
    kernel: VelvetNoiseKernel,
    next: (usize, f32),
    n: usize,
}

impl<T, U> VelvetNoise<VelvetNoiseKernel<T, U>>
where
    T: Iterator<Item = usize>,
    U: Iterator<Item = f32>,
{
    fn from_kernel(mut kernel: VelvetNoiseKernel<T, U>) -> VelvetNoise<VelvetNoiseKernel<T, U>> {
        let next = kernel.next().unwrap();
        VelvetNoise {
            kernel: kernel,
            n: 0,
            next: next,
        }
    }
}

impl<T, U> Iterator for VelvetNoise<VelvetNoiseKernel<T, U>>
where
    T: Iterator<Item = usize>,
    U: Iterator<Item = f32>,
{
    type Item = f32;

    fn next(&mut self) -> Option<Self::Item> {
        let value = match self.n == self.next.0 {
            true => {
                let sample = self.next.1;
                self.next = self.kernel.next().unwrap();
                sample
            }
            false => 0.,
        };

        self.n += 1;

        Some(value)
    }
}

pub fn original_velvet_noise(
    density: f32,
    sample_rate: f32,
) -> VelvetNoise<VelvetNoiseKernel<OVNImpulseLocations, Choice>> {
    let kernel = VelvetNoiseKernel(
        OVNImpulseLocations::new(density as usize, sample_rate as usize),
        Choice::classic(),
    );

    VelvetNoise::from_kernel(kernel)
}

pub fn crushed_original_velvet_noise(
    density: f32,
    sample_rate: f32,
    skew: f64,
) -> VelvetNoise<VelvetNoiseKernel<OVNImpulseLocations, Choice>> {
    let kernel = VelvetNoiseKernel(
        OVNImpulseLocations::new(density as usize, sample_rate as usize),
        Choice::crushed(skew),
    );

    VelvetNoise::from_kernel(kernel)
}

pub fn additive_velvet_noise(
    density: f32,
    sample_rate: f32,
    delta: f32,
) -> VelvetNoise<VelvetNoiseKernel<ARNImpulseLocations, Choice>> {
    let kernel = VelvetNoiseKernel(
        ARNImpulseLocations::new(density, sample_rate, delta),
        Choice::classic(),
    );

    VelvetNoise::from_kernel(kernel)
}

pub fn crushed_additive_velvet_noise(
    density: f32,
    sample_rate: f32,
    delta: f32,
    skew: f64,
) -> VelvetNoise<VelvetNoiseKernel<ARNImpulseLocations, Choice>> {
    let kernel = VelvetNoiseKernel(
        ARNImpulseLocations::new(density, sample_rate, delta),
        Choice::crushed(skew),
    );

    VelvetNoise::from_kernel(kernel)
}

#[cfg(test)]
mod tests {
    use super::*;
    use more_asserts::*;

    macro_rules! assert_close_enough {
        ($value:expr, $expected:expr, $range:expr) => {{
            let (value, expected, range) = (&($value), &($expected), &($range));
            assert_ge!(*value, *expected - *range);
            assert_le!(*value, *expected + *range);
        }};
    }

    fn spread(data: &[f32]) -> f32 {
        let dev = (0..data.len() - 1)
            .map(|i| (*data)[i + 1] as f32 - (*data)[i] as f32)
            .collect::<Vec<f32>>();

        let max = dev.iter().cloned().fold(f32::NAN, f32::max);
        let min = dev.iter().cloned().fold(f32::NAN, f32::min);
        max - min
    }

    fn save(sample_rate: u32, data: Vec<f32>, filepath: &str) {
        let spec = hound::WavSpec {
            channels: 1,
            sample_rate: sample_rate,
            bits_per_sample: 32,
            sample_format: hound::SampleFormat::Float,
        };
        let mut writer = hound::WavWriter::create(filepath, spec).unwrap();
        for s in data.into_iter() {
            writer.write_sample(s).unwrap();
        }
        writer.finalize().unwrap();
    }

    #[test]
    fn window_size() {
        let vil = OVNImpulseLocations::new(441, 44100);
        assert_eq!(vil.td, 100);
    }

    #[test]
    fn iter_locations() {
        // Run iterator for a long time and check that the average impulse density is correct
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf

        let density = 2000;
        let sample_rate = 96000;
        let seconds = 100;
        let until = sample_rate * seconds;

        let vil = OVNImpulseLocations::new(density, sample_rate);
        let num_impulses = vil.take_while(|loc| (*loc) < until).count();

        assert_eq!(num_impulses / seconds, density);
    }

    #[test]
    fn iter_arn_locations() {
        // Run iterator for a long time and check that the average impulse density is correct
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf

        let density = 2000;
        let sample_rate = 96000;
        let seconds = 100;
        let until = sample_rate * seconds;

        let max_spread = (sample_rate as f32 / density as f32) * 2.;

        let locs1 = ARNImpulseLocations::new(density as f32, sample_rate as f32, 0.);
        let impulses1 = locs1
            .take_while(|loc| (*loc) < until)
            .map(|x| x as f32)
            .collect::<Vec<f32>>();
        assert_close_enough!(spread(impulses1.as_slice()), 0., 0.01);

        let locs2 = ARNImpulseLocations::new(density as f32, sample_rate as f32, 1.);
        let impulses2 = locs2
            .take_while(|loc| (*loc) < until)
            .map(|x| x as f32)
            .collect::<Vec<f32>>();
        assert_close_enough!(spread(impulses2.as_slice()), max_spread, 2.);

        let locs3 = ARNImpulseLocations::new(density as f32, sample_rate as f32, 0.5);
        let impulses3 = locs3
            .take_while(|loc| (*loc) < until)
            .map(|x| x as f32)
            .collect::<Vec<f32>>();
        assert_close_enough!(spread(impulses3.as_slice()), max_spread * 0.5, 2.);
    }

    #[test]
    fn classic_choice_is_even() {
        let c = Choice::classic();
        let total: f32 = c.take(1_000_000).sum();
        assert_close_enough!(total / 1_000_000., 0., 0.01);
    }

    #[test]
    fn crushed_choice_can_skew_positive() {
        let c = Choice::crushed(0.75);
        let total: f32 = c.take(1_000_000).sum();
        assert_close_enough!(total / 1_000_000., 0.5, 0.01);
    }

    #[test]
    fn crushed_choice_can_skew_negative() {
        let c = Choice::crushed(0.25);
        let total: f32 = c.take(1_000_000).sum();
        assert_close_enough!(total / 1_000_000., -0.5, 0.01);
    }

    #[test]
    fn kernel_init() {
        let kern = VelvetNoiseKernel(OVNImpulseLocations::new(10, 20), Choice::classic());

        for (i, x) in kern.skip(1).take(10) {
            assert_gt!(i, 0);
            assert_ne!(x, 0.);
        }
    }

    #[test]
    fn noise_from_kernel() {
        let kernel = VelvetNoiseKernel(OVNImpulseLocations::new(10, 20), Choice::classic());

        let noise = VelvetNoise::from_kernel(kernel);
        for sample in noise.skip(1).take(20) {
            assert!([-1., 0., 1.].contains(&sample));
        }
    }

    #[test]
    fn iter_noise_samples() {
        // Check that a snippet of velvet noise contains at least one each of -1. and 1., and that
        // the overall density is correct. We cannot assert the ratio of -1. to 1. since it's
        // determined by the rand crate.
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf

        let density: f32 = 2000.;
        let sample_rate: f32 = 96000.;
        let take_n = sample_rate as usize;

        let noise = original_velvet_noise(density, sample_rate);
        let samples: Vec<f32> = noise.take(take_n).collect();

        assert_eq!(samples.iter().map(|s| *s as i32).max(), Some(1));
        assert_eq!(samples.iter().map(|s| *s as i32).min(), Some(-1));
        assert_eq!(
            samples.iter().map(|s| (*s).abs()).sum::<f32>(),
            density as f32
        );

        // save(sample_rate as u32, samples, "iter_noise_samples.wav");
    }

    #[test]
    fn iter_crushed_noise_samples() {
        // Check that a snippet of velvet noise contains at least one each of -1. and 1., and that
        // the overall density is correct. We cannot assert the ratio of -1. to 1. since it's
        // determined by the rand crate.
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf

        let density: f32 = 8000.;
        let sample_rate: f32 = 96000.;
        let crush_factor = 0.75;
        let take_n = sample_rate as usize;

        let noise = crushed_original_velvet_noise(density, sample_rate, crush_factor);
        let samples: Vec<f32> = noise.take(take_n).collect();

        assert_eq!(samples.iter().cloned().fold(f32::NAN, f32::max), 1.);
        assert_eq!(samples.iter().cloned().fold(f32::NAN, f32::min), -1.);
        assert_gt!(samples.iter().cloned().sum::<f32>(), 0.);

        // save(sample_rate as u32, samples, "iter_crushed_noise_samples.wav");
    }

    #[test]
    fn iter_crushed_arn_noise_samples() {
        // Check that a snippet of velvet noise contains at least one each of -1. and 1., and that
        // the overall density is correct. We cannot assert the ratio of -1. to 1. since it's
        // determined by the rand crate.
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf

        let density = 8000.;
        let sample_rate = 96000.;
        let delta = 0.5;
        let crush_factor = 0.95;
        let take_n = sample_rate as usize;

        let noise = crushed_additive_velvet_noise(density, sample_rate, delta, crush_factor);
        let samples: Vec<f32> = noise.take(take_n).collect();

        assert_eq!(samples.iter().cloned().fold(f32::NAN, f32::max), 1.);
        assert_eq!(samples.iter().cloned().fold(f32::NAN, f32::min), -1.);
        assert_gt!(samples.iter().cloned().sum::<f32>(), 0.);

        // save(sample_rate as u32, samples, "iter_crushed_arn_noise_samples.wav");
    }
}
