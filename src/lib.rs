extern crate rand;

use rand::{Rng, SeedableRng};
use rand::rngs::SmallRng;
use rand::distributions::{Bernoulli, Distribution};

/// Original Velvet Noise impulse location iterator
pub struct OVNImpulseLocations {
    m: std::ops::RangeFrom<usize>,
    td: usize,
    r1m: SmallRng
}

impl OVNImpulseLocations {
    /// density is non-zero pulses per second
    /// sample_rate is total samples per second
    pub fn new(density: usize, sample_rate: usize) -> OVNImpulseLocations {
        OVNImpulseLocations {
            m: (0..),
            td: sample_rate / density,
            r1m: SmallRng::from_entropy()
        }
    }
}

impl Iterator for OVNImpulseLocations {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        let val = (self.m.next().unwrap() * self.td) + self.r1m.gen_range(0, self.td);
        Some(val)
    }
}


/// Impulse indexes that wrap around a given buffer size
pub struct ChunkedOVNImpulseLocations {
    impulses: OVNImpulseLocations,
    chunk_length: usize,
    base: usize,
    store: Option<usize>
}

impl ChunkedOVNImpulseLocations {
    pub fn new(density: usize, sample_rate: usize, chunk_length: usize) -> ChunkedOVNImpulseLocations {
        ChunkedOVNImpulseLocations {
            impulses: OVNImpulseLocations::new(density, sample_rate),
            chunk_length: chunk_length,
            base: 0,
            store: None
        }
    }
}

impl Iterator for ChunkedOVNImpulseLocations {
    type Item = Vec<usize>;

    fn next(&mut self) -> Option<Self::Item> {
        let mut chunk: Vec<usize> = vec![];
        
        if let Some(x) = self.store {
            chunk.push(x);
            self.store = None;
        }
        
        loop {
            let x = self.impulses.next().unwrap();
            if x - self.base < self.chunk_length {
                chunk.push(x);
            } else {
                self.store = Some(x);
                self.base += self.chunk_length;
                break;
            }
        }

        Some(chunk)
    }
}

/// Audio signal generated by the given impulse location iterator
struct VelvetNoise {
    impulses: OVNImpulseLocations,
    r2m: (Bernoulli, SmallRng),
    n: usize,
    kovn: usize
}

impl VelvetNoise {
    fn new(density: usize, sample_rate: usize) -> VelvetNoise {
        let mut imps = OVNImpulseLocations::new(density, sample_rate);
        let kovn = imps.next().unwrap();
        VelvetNoise {
            impulses: imps,
            r2m: (Bernoulli::new(0.5).unwrap(), SmallRng::from_entropy()),
            n: 0,
            kovn: kovn
        }
    }
}

impl Iterator for VelvetNoise {
    type Item = f32;

    fn next(&mut self) -> Option<Self::Item> {
        let value = match self.n == self.kovn {
            true => {
                self.kovn = self.impulses.next().unwrap();
                match self.r2m.0.sample(&mut self.r2m.1) {
                    true => Some(1.),
                    false => Some(-1.)
                }
            },
            false => Some(0.)
        };
        self.n += 1;
        value
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn window_size() {
        let vil = OVNImpulseLocations::new(441, 44100);
        assert_eq!(vil.td, 100);
    }

    #[test]
    fn iter_locations() {
        
        // Run iterator for a long time and check that the average impulse density is correct
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf
        
        let density = 2000;
        let sample_rate = 96000;
        let seconds = 100;
        let until = sample_rate * seconds;
        
        let vil = OVNImpulseLocations::new(density, sample_rate);
        let num_impulses = vil.take_while(|loc| (*loc) < until).count();

        assert_eq!(num_impulses / seconds, density);
    }

    #[test]
    fn iter_chunked_locations() {
        
        let density = 2000;
        let sample_rate = 96000;
        let seconds = 100;
        let until = sample_rate * seconds;
        let chunk_size = 960;
        
        let cvil = ChunkedOVNImpulseLocations::new(density, sample_rate, chunk_size);
        let num_impulses = cvil.take(until / chunk_size).flatten().count();
        
        assert_eq!(num_impulses / seconds, density);
    }

    #[test]
    fn single_chunk() {
        
        let density = 2000;
        let sample_rate = 96000;
        
        let chunk = ChunkedOVNImpulseLocations::new(density, sample_rate, 960).next().unwrap();
        println!("{:?}", chunk);
    }

    #[test]
    fn iter_noise_samples() {
        
        // Check that a snippet of velvet noise contains at least one each of -1. and 1., and that
        // the overall density is correct. We cannot assert the ratio of -1. to 1. since it's
        // determined by the rand crate.
        // density and sample rate from http://dafx.de/paper-archive/2019/DAFx2019_paper_53.pdf
        
        let density = 2000;
        let sample_rate = 96000;
        
        let noise = VelvetNoise::new(density, sample_rate);
        let samples: Vec<f32> = noise.take(sample_rate).collect();

        assert_eq!(samples.iter().map(|s| *s as i32).max(), Some(1));
        assert_eq!(samples.iter().map(|s| *s as i32).min(), Some(-1));
        assert_eq!(samples.iter().map(|s| (*s).abs()).sum::<f32>(), density as f32);

        // let spec = hound::WavSpec {
        //     channels: 1,
        //     sample_rate: sample_rate as u32,
        //     bits_per_sample: 32,
        //     sample_format: hound::SampleFormat::Float,
        // };
        // let mut writer = hound::WavWriter::create("iter_noise_samples.wav", spec).unwrap();
        // for s in samples.into_iter() {
        //     writer.write_sample(s);
        // }
    }
}
